## App Architecture
The most common architectural principles are: separation of concerns and driving UI from a model.

#### 1. Separation of concerns
The separation of concerns design principle states that the app should be divided into classes, each with separate responsibilities.

#### 2. Driving UI from a model
Another important principle is that you should drive your UI from a model, preferably a persistent model. 

> * Models are components that are responsible for handling the data for an app. 
> * They're independent from the Views and app components in your app, so they're unaffected by the app's lifecycle and the associated concerns.

#### Main Classes /Components in Android Architecture :
1. UI Controller (Activity/ Fragments)
2. ViewModel
3. LiveData
4. Room

These components deal lifecycle related problems.

![](https://developer.android.com/codelabs/basic-android-kotlin-training-viewmodel/img/53dd5e42f23ffba9.png)

#### UI controller (Activity/ Fragment)
Activities and fragments are UI controllers. 
The Android system can destroy UI controllers at any time based on certain user interactions or because of system conditions like low memory.
 Because these events aren't under your control, you shouldn't store any app data or state in UI controllers. 
Instead, the decision-making logic about the data should be added in your ViewModel.

#### ViewModel

The ViewModel is a model of the app data that is displayed in the views.
Models are components that are responsible for handling the data for an app. 

> To use ViewModel: To implement ViewModel in your app, extend the ViewModel class, which is from the architecture components library, and store app data within that class.

<table>
<tr>
<td>
Fragment / activity (UI controller) responsibilities
</td>
<td>
ViewModel responsibilities
</td>
</tr>
<tr>
<td>
Activities and fragments are responsible for drawing views and data to the screen and responding to the user events.
</td>
<td>
ViewModel is responsible for holding and processing all the data needed for the UI. It should never access your view hierarchy (like view binding object) or hold a reference to the activity or the fragment.
</td>
</tr>
</table>

#### Add a ViewModel

Your app will be architected in the following way. MainActivity contains a GameFragment, and the GameFragment will access information about the game from the GameViewModel

![](https://developer.android.com/codelabs/basic-android-kotlin-training-viewmodel/img/2094f3414ddff9b9.png)

* To use the ViewModel in your app, verify that you have the ViewModel library dependency inside the dependencies block. This step is already done for you.
```
// ViewModel
implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0'
```
* Create ViewModel class.

```
class ExampleViewModel : ViewModel() {
}
```
* Add ViewModel to the activity or fragment.
    * To associate a ViewModel to a UI controller (activity / fragment), create a reference (object) to the ViewModel inside the UI controller.
    ```
    private val viewModel: ExampleViewModel by viewModels()
    ```
    > import androidx.fragment.app.viewModels.

###### Kotlin property delegate (important)

* In Kotlin, each mutable (var) property has default getter and setter functions automatically generated for it. The setter and getter functions are called when you assign a value or read the value of the property.
* For a read-only property (val), it differs slightly from a mutable property. Only the getter function is generated by default. This getter function is called when you read the value of a read-only property.

Property delegation in Kotlin helps you to handoff the getter-setter responsibility to a different class.

This class (called delegate class) provides getter and setter functions of the property and handles its changes.
A delegate property is defined using the by clause and a delegate class instance

```
// Syntax for property delegation
var <property-name> : <property-type> by <delegate-class>()
```
If we initialize the view model using default GameViewModel constructor , app will lose the state of the viewModel reference when the device goes through a configuration change:
```
private val viewModel = GameViewModel()
```
* Instead, use the property delegate approach and delegate the responsibility of the viewModel object to a separate class called viewModels.
* When you access the viewModel object, it is handled internally by the delegate class, viewModels.
* Delegate class creates viewModel object ,retains its values  through configurational changes and returns the value when requested.
