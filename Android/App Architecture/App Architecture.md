## App Architecture
The most common architectural principles are: separation of concerns and driving UI from a model.

#### 1. Separation of concerns
The separation of concerns design principle states that the app should be divided into classes, each with separate responsibilities.

#### 2. Driving UI from a model
Another important principle is that you should drive your UI from a model, preferably a persistent model. 

> * Models are components that are responsible for handling the data for an app. 
> * They're independent from the Views and app components in your app, so they're unaffected by the app's lifecycle and the associated concerns.

#### Main Classes /Components in Android Architecture :
1. UI Controller (Activity/ Fragments)
2. ViewModel
3. LiveData
4. Room

These components deal lifecycle related problems.

![](https://developer.android.com/codelabs/basic-android-kotlin-training-viewmodel/img/53dd5e42f23ffba9.png)

#### UI controller (Activity/ Fragment)
Activities and fragments are UI controllers. 
The Android system can destroy UI controllers at any time based on certain user interactions or because of system conditions like low memory.
 Because these events aren't under your control, you shouldn't store any app data or state in UI controllers. 
Instead, the decision-making logic about the data should be added in your ViewModel.

#### ViewModel

The ViewModel is a model of the app data that is displayed in the views.
Models are components that are responsible for handling the data for an app. 

> To use ViewModel: To implement ViewModel in your app, extend the ViewModel class, which is from the architecture components library, and store app data within that class.

<table>
<tr>
<td>
Fragment / activity (UI controller) responsibilities
</td>
<td>
ViewModel responsibilities
</td>
</tr>
<tr>
<td>
Activities and fragments are responsible for drawing views and data to the screen and responding to the user events.
</td>
<td>
ViewModel is responsible for holding and processing all the data needed for the UI. It should never access your view hierarchy (like view binding object) or hold a reference to the activity or the fragment.
</td>
</tr>
</table>

# Add a ViewModel

Your app will be architected in the following way. MainActivity contains a GameFragment, and the GameFragment will access information about the game from the GameViewModel

![](https://developer.android.com/codelabs/basic-android-kotlin-training-viewmodel/img/2094f3414ddff9b9.png)

* To use the ViewModel in your app, verify that you have the ViewModel library dependency inside the dependencies block. This step is already done for you.
```kotlin
// ViewModel
implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0'
```
* Create ViewModel class.

```kotlin
class ExampleViewModel : ViewModel() {
}
```
* Add ViewModel to the activity or fragment.
    * To associate a ViewModel to a UI controller (activity / fragment), create a reference (object) to the ViewModel inside the UI controller.
    ```kotlin
    private val viewModel: ExampleViewModel by viewModels()
    ```
    > import androidx.fragment.app.viewModels.

## Kotlin property delegate (important)

* In Kotlin, each mutable (var) property has default getter and setter functions automatically generated for it. The setter and getter functions are called when you assign a value or read the value of the property.
* For a read-only property (val), it differs slightly from a mutable property. Only the getter function is generated by default. This getter function is called when you read the value of a read-only property.

Property delegation in Kotlin helps you to handoff the getter-setter responsibility to a different class.

This class (called delegate class) provides getter and setter functions of the property and handles its changes.
A delegate property is defined using the by clause and a delegate class instance

```kotlin
// Syntax for property delegation
var <property-name> : <property-type> by <delegate-class>()
```
If we initialize the view model using default GameViewModel constructor , app will lose the state of the viewModel reference when the device goes through a configuration change:
```kotlin
private val viewModel = GameViewModel()
```
* Instead, use the property delegate approach and delegate the responsibility of the viewModel object to a separate class called viewModels.
* When you access the viewModel object, it is handled internally by the delegate class, viewModels.
* Delegate class creates viewModel object ,retains its values  through configurational changes and returns the value when requested.

# Move data to the ViewModel

* Activities / Fragment classes are responsible for drawing views and data to the screen.
* While ViewModel is responsible for holding and processing all the data needed for the UI.

Set the data variables in the ViewModel class.
```kotlin
class ExampleViewModel : ViewModel() {

    private var score = 0
    private var currentWordCount = 0
    private var currentScrambledWord = "test"
...
```
>Problems:
>private  properties in ViewModel are not accessible by the UI controller.
To resolve this we cant make the visibility of the properties private because its risky because an outside class could change the data in unexpected ways that don't follow the game rules specified in the view model.
*  For example, an outside class could change the score to a negative value.

>Inside the ViewModel, the data should be editable, so they should be private and var. From outside the ViewModel, data should be readable, but not editable, so the data should be exposed as public and val. To achieve this behavior, Kotlin has a feature called a backing property.

## Backing property

A backing property allows you to return something from a getter other than the exact object.

 To implement a backing property, you will override the getter method to return a read-only version of your data.

 ```kotlin
 // Declare private mutable variable that can only be modified
// within the class it is declared.
private var _count = 0 

// Declare another public immutable field and override its getter method. 
// Return the private property's value in the getter method.
// When count is accessed, the get() function is called and
// the value of _count is returned. 
val count: Int
   get() = _count

```
#### Inside the ViewModel class:
* The property _count is private and mutable. Hence, it is only accessible and editable within the ViewModel class. The convention is to prefix the private property with an underscore.

#### Outside the ViewModel class:

* The default visibility modifier in Kotlin is public, so count is public and accessible from other classes like UI controllers.
Since only the get() method is being overridden, this property is immutable and read-only.
When an outside class accesses this property, it returns the value of _count and its value can't be modified.
This protects the app data inside the ViewModel from unwanted and unsafe changes by external classes, but it allows external callers to safely access its value.

#### Adding backing property to any property/variable in the ViewModel class:

Inside the ViewModel class , change a property , say , score declaration to add a backing property.
* Now, _score is accessible and editable only within the ViewModel class.
* The UI Controller can access the value of _score by calling score.

```kotlin
private var _score = 0
val score: Int
   get() = _score
```
>Warning: Never expose mutable data fields from your ViewModelâ€”make sure this data can't be modified from another class. Mutable data inside the ViewModel should always be private.

## Lifecycle of a ViewModel

ViewModel is alive as long as the scope of the activity or fragment is alive.
* IMPORTANT: ViewModel is not destroyed if its owner is destroyed for a configuration change, such as screen rotation.
The new instance of the owner reconnects to the existing ViewModel.

![](https://developer.android.com/codelabs/basic-android-kotlin-training-viewmodel/img/18e67dc79f89d8a.png)

* onCreate() is called when the ViewModel is created.
* onCleared() is called when the ViewModel is destroyed.

## Populating ViewModel

Populate the ViewModel with helper functions that can be used by the UI controller , like score variable.

* lateinit : Declares a variable that is not initialized until the first access.
* Use the init block to initialize the lateinit properties in the class .
```kotlin
init{
  The function that contains the lateinit properties.
}
```

